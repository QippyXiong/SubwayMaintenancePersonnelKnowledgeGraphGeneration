# 图谱构建模型控制类的实现

## 遇到的问题

### 是否模型设置/获取是否需要实现多实例

    主要考虑到不止实现一种模型，模型实例化的模型可能也不止一种，而采用`set`，`get`这样的接口，就意味着只能实例化一个模型。

    实例化一个模型明显的局限就是你同时只能运行一个模型，当然它也带来了许多关于程序设计的好处，主要是以下几点：

    1.  不需要模型的动态释放，因为就这一个，加载的时候释放老模型就行，多实例实现我们需要选定方案到底确定哪个模型
    2.  不需要考虑预测任务，训练任务调用哪个模型实例，调用接口简单

    劣势呢，主要是以下几点：

    3.  对于多个语料抽取任务，切换语料类型，就需要重新加载模型

    如果要实现多实例，相对于单实例的实现，主要考虑这么些东西：

    1.  如何搜索实例，我们应当提供怎样的接口来让用户能良好地选择实例？
        主要是，一个列表，选择实例任务的时候，我们要显示些什么？目前主要考虑是：
            | 名称 | 模型类型 | 加权F1值 | 加权精确度 | 加权召回率 |
        这些信息应该足够让用户确定实例，搜索的话，实现的时候直接通过下标搜索吧，通过`get_list`这样的实现获得一个模型列表，在列表中选择

        目前来看就是，绑定存储模型的实现，我们读取已经存储的模型实例有哪些，提供接口由用户选择加载哪些模型实例。 

    2.  

### 数据集处理问题

    由于要实现多种模型，一个数据集的输出不应当只能满足一种模型。

    为了使用`DataLoader`实现自动的`batch`，我们不应当再构建`DataLoader`对象后再处理数据，比较好的一个办法是通过传入嵌入方法的方式，在`__getitem__`返回前调用此嵌入方法，将嵌入方法的结果作为返回值，构建方法时传入不同的嵌入代码，来满足功能。

    不过这样也带来了一个问题，需要为每个类型模型和每个数据集都写一份嵌入代码，假如你有$m$个模型，$n$个数据集，那么你需要写$n\times m$份数据处理的嵌入代码，而且映射结构不太好定义，一维到一维的映射通过map就能实现，二维映射至一维就麻烦多了。


## 计划功能列表

    1. 初始化模型
    2. 训练模型
    3. 调度模型（调度模型在设备之间移动）

## 正在实现的功能

## 已经实现的功能